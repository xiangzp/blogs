## 深拷贝

### 方法一：利用JSON

```js
var a = {}
var b = JSON.parse(JSON.stringify(a))
```

有局限性，会无法拷贝函数、日期、正则等特殊的对象



### 方法二：structuredClone

> https://developer.mozilla.org/en-US/docs/Web/API/structuredClone

新的web API，有兼容性问题

|                   | Chrome | Edge | Firefox | Internet Explorer | Opera | Safari | WebView Android | Chrome Android | Firefox for Android | Opera Android | Safari on iOS | Samsung Internet | Deno  |
| :---------------- | :----: | :--: | :-----: | :---------------: | :---: | :----: | :-------------: | :------------: | :-----------------: | :-----------: | :-----------: | :--------------: | :---: |
| `structuredClone` |  98✅   | 98✅  |   94✅   |         ❌         |  84✅  | 15.4✅  |       98✅       |      98✅       |         94✅         |       ❌       |       ✅       |        ❌         | 1.14✅ |



### 方法三：自实现

根据不同数据类型进行深度克隆。

#### 引用数据类型

预设的引用数据类型：

> * ES6之前： Object, Array, Date, RegExp, Error,
> * ES6之后： Map, Set, WeakMap, WeakSet,

#### 代码

```js
// 引用类型构造
const reference = [Date, RegExp, Set, WeakSet, Map, WeakMap, Error];

function cloneDeep (obj, hash = new WeakMap()) {
  // 根据hash存储的对象判断，如果有直接返回
  if (hash.has(obj)) return obj
  // 定义返回
  let res = null
  // 判断是否是已知的引用类型
  if (reference.includes(obj?.constructor)) {
    res = new obj.constructor(obj)
  } else if (Array.isArray(obj)) {
    // 对数组做针对处理
    res = []
    obj.forEach((e, index) => {
      // 递归处理
      res[i] = deepClone(e);
    })
  } else if (typeof obj === "Object" && obj !== null) {
    // 处理自定义obj
    res = {}
    for (const key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        // 递归处理
        res[key] = deepClone(obj[key]);
      }
    }
  } else {
    // 数字、字符串 直接赋值
    res = obj
  }
  // 添加hash缓存
  hash.set(obj, res)
  // 返回
  return res
}
```

