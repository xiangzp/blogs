---
title: JavaScript中数值的二进制存储和二进制补码
date: 
        2019-08-08 15:16:31
tags: [JavaScript基础]
categories: 前端
---
 # 概念
ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。

而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。

对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。

# 有符号整数

对于有符号的整数， 32 位中的前 31 位用于表示整数的值。
**第 32 位用于表示数值的符号： 0 表示正数， 1 表示负数。**

这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。

## 正数

其中，正数以纯二进制格式存储， 31 位中的每一位都表示 2 的幂。第一位（叫做位 0）表示 20，第二位表示 21，以此类推 。没有用的以0填充，即忽略不计 。 

例如，数值 18 的二进制表示是

0000 0000 0000 0000 0000 0000 0001 0010

或者更简洁的 10010。这是 5 个有效位，这 5 位本身就决定了实际的值。

## 负数

负数同样以二进制码存储，但使用的格式是**二进制补码**。

计算一个数值的二进制补码，需要经过下列 3 个步骤：

* 求这个数值绝对值的二进制码（例如，要求-18 的二进制补码，先求 18 的二进制码）；

* 求二进制反码，即将 0 替换为 1，将 1 替换为 0；

* 得到的二进制反码加 1。

要根据这 3 个步骤求得-18 的二进制码，首先就要求得 18 的二进制码，即：

0000 0000 0000 0000 0000 0000 0001 0010

然后，求其二进制反码，即 0 和 1 互换：

1111 1111 1111 1111 1111 1111 1110 1101

最后，二进制反码加 1：

1111 1111 1111 1111 1111 1111 1110 1101

+&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;1

---------------------------------------

1111 1111 1111 1111 1111 1111 1110 1110

这样，就求得了-18 的二进制表示，即 

1111 1111 1111 1111 1111 1111 1110 1110

要注意的是，在处理有符号整数时，是不能访问位 31 的。

ECMAScript 会尽力向我们隐藏所有这些信息。

换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。

```javascript

var num = -18;
alert(num.toString(2)); // "-10010"

```

要把数值-18 转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补
码并将其以更合乎逻辑的形式展示了出来。